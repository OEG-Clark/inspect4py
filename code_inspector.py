"""Code Inspector

This script allows the user to inspect a file or files within directory 
(and its subdirectories) and extract all the most relevant information, 
such as documentations, classes (and their methods), functions, etc.

To extract information from docstrings, we have started with the codes
documented. But in the future we will extend the code
to support others.  

This tool accepts (for now) only python code (.py)

This script requires `ast`, `cdmcfparser` and `docsting_parse`
be installed within the Python environment you are running 
this script in.

"""

import ast
import sys
import json
import os
from os import listdir
from os.path import isfile, join
import tokenize
from pprint import pprint
from cdmcfparser import getControlFlowFromFile
from staticfg import builder
import argparse
from docstring_parser import parse as docParse

### Path to store the results
outputPath="OutputDir"
FLAG_PNG=1
###

class Code_Inspection:
    def __init__(self,path, outCfPath, outJsonPath, format="png"):
        """ init method initiliazes the Code_Inspection object

        :param self self: represent the instance of the class
        :param str path: the file to inspect
        :param str outCfPath: the output directory to store the control
			  flow information
        :param str outJsonPath: the output directory to store the json file
			  with features extracted from the ast tree.
        :param str format: format to store the control flow diagram
        """

        self.path = path
        self.outJsonPath = outJsonPath
        self.outCfPath = outCfPath
        self.tree = self.parser_file()
        self.fileInfo = self.inspect_file() 
        self.controlFlowInfo = self.inspect_controlflow(format)
        self.funcsInfo = self.inspect_functions()
        self.classesInfo = self.inspect_classes()
        self.depInfo = self.inspect_dependencies()
        self.fileJson = self.file_json()


    def parser_file(self):
        """ parse_file method parsers a file as an AST tree

        :param self self: represent the instance of the class
        :return ast.tree: the file as an ast tree
        """

        with tokenize.open(self.path) as f:
            return ast.parse(f.read(), filename=self.path)

    def inspect_file(self):
        """ inspec_file method extracts the features at file level.
        Those features are path, fileNameBase, extension, docstring
	The method support several levels of docstrings extraction,
        such as file's long, short a full descrition.

        :param self self: represent the instance of the class
        :return dictionary a dictionary with the file information extracted
        """
        fileInfo={}
        fileInfo["path"]=self.path
        fileName = os.path.basename(self.path).split(".")
        fileInfo["fileNameBase"]=fileName[0]
        fileInfo["extension"]=fileName[1]
        ds_m=ast.get_docstring(self.tree)
        docstring=docParse(ds_m)
        fileInfo["doc"]={}
        fileInfo["doc"]["long_description"]=docstring.long_description
        fileInfo["doc"]["short_description"]=docstring.short_description
        fileInfo["doc"]["full"]=ds_m
        #fileInfo["doc"]["meta"]=docstring.meta
        return fileInfo

    def inspect_controlflow(self,format):
        """inspect_controlFlow uses two methods for 
        extracting the controlflow of a file. One as a
        text and another as a figure (PNG/PDF/DOT).   
        

        :param self self: represent the instance of the class
        :param str format: represent the format to save the figure
        :return dictionary: a dictionary with the all information extracted (at file level)
        """
        controlInfo={}
        cfg = getControlFlowFromFile(self.path)
        cfg_txt=self._formatFlow(str(cfg))
        cfg_txt_file=self.outCfPath+"/"+ self.fileInfo["fileNameBase"] + ".txt" 
        
        with open(cfg_txt_file, 'w') as outfile:
           outfile.write(cfg_txt)
        controlInfo["cfg"]= cfg_txt_file
        #print("---> %s" % self.path)

        if FLAG_PNG:
            cfg_visual = builder.CFGBuilder().build_from_file(self.fileInfo["fileNameBase"], self.path)
            cfg_path=self.outCfPath+"/"+ self.fileInfo["fileNameBase"]
            cfg_visual.build_visual(cfg_path, format=format, calls=False, show=False)
            controlInfo["png"]=cfg_path+"."+ format
            #delete the second file generated by the cfg_visual (not needed!)
            os.remove(cfg_path)
        else:
            controlInfo["png"]="None"
        return controlInfo
    
    def inspect_functions(self):
        """ inspect_functions detects all the functions in a AST tree, and calls
        to _f_definitions method to extracts all the features at function level.

        :param self self: represent the instance of the class
        :return dictionary: a dictionary with the all functions information extracted
        """

        functions_definitions = [node for node in self.tree.body if isinstance(node, ast.FunctionDef)]
        return self._f_definitions(functions_definitions)

    def inspect_classes(self):
        """ inspect_classes detecs all the classes and their methods,
         and extracts their features. It also calls to _f_definitions method
        to extract features at method level.

        The features extracted are name, docstring (this information is further analysed
        and classified into several categories), extends, start
        and end of the line and methods.

        :param self self: represent the instance of the class
        :return dictionary: a dictionary with the all classes information extracted
        """

        classes_definitions = [node for node in self.tree.body if isinstance(node, ast.ClassDef)]
        classesInfo={}
        for c in classes_definitions:
            classesInfo[c.name]={}
            ds_c=ast.get_docstring(c)
            docstring=docParse(ds_c)
            classesInfo[c.name]["doc"]={}
            classesInfo[c.name]["doc"]["long_description"]=docstring.long_description
            classesInfo[c.name]["doc"]["short_description"]=docstring.short_description
            classesInfo[c.name]["doc"]["full"]=ds_c
            #classesInfo[c.name]["doc"]["meta"]=docstring.meta

            try:
                classesInfo[c.name]["extend"]=[b.id for b in c.bases]
            except:
                classesInfo[c.name]["extend"]=[b.value.func.id if isinstance(b,ast.Call) and hasattr(b, 'value') else b.value.id if hasattr(b, 'value') else "" for b in c.bases]
            classesInfo[c.name]["min_max_lineno"] = self._compute_interval(c)
            methods_definitions=[node for node in c.body if isinstance(node, ast.FunctionDef)]
            classesInfo[c.name]["methods"]=self._f_definitions(methods_definitions)
        return classesInfo

    def inspect_dependencies(self):
        """ inspect_dependencies method extracts the features at dependencies level.
        Those features are module , name, and alias.

        :param self self: represent the instance of the class
        :return dictionary: a dictionary with the all dependencies information extracted
        """

        depInfo={}
        num=0
        for node in ast.iter_child_nodes(self.tree):
            if isinstance(node, ast.Import):
                module=[]
            elif isinstance(node, ast.ImportFrom):  
                module = node.module.split('.')
            else:
                continue
            for n in node.names:
                d_name="dep_"+str(num)
                depInfo[d_name]={}
                depInfo[d_name]["module"] = module
                depInfo[d_name]["name"] = n.name.split('.')
                depInfo[d_name]["alias"] = n.asname
                num=num+1

        return depInfo 


    def file_json(self):
        """file_json method aggregates all the features previously
        extracted from a given file such as, functions, classes 
        and dependencies levels into the same dictionary.
        
        It also writes this new dictionary to a json file.

        :param self self: represent the instance of the class
        :return dictionary: a dictionary with the all information extracted (at file level)
        """

        FileDict={}
        FileDict["file"]=self.fileInfo
        FileDict["dependencies"]=self.depInfo
        FileDict["classes"]=self.classesInfo
        FileDict["functions"]=self.funcsInfo
        FileDict["controlflow"]=self.controlFlowInfo

        json_file=self.outJsonPath+"/" +self.fileInfo["fileNameBase"] + ".json" 
        with open(json_file, 'w') as outfile:
           json.dump(FileDict, outfile)
        return FileDict 


    def _f_definitions(self, functions_definitions):
        """_f_definitions extracts the name, args, doscstring 
        returns, raises of a list of functions or a methods.

        Furthermore, it also extracts automatically several values
        from a docstring, such as long and short description, arguments' 
        name, description, type, default values and if it they are optional
        or not. 

        :param self self: represent the instance of the class
        :param list functions_definitions: represent a list with all functions or methods nodes
        :return dictionary: a dictionary with the all the information at function/method level
        """

        funcsInfo={}
        for f in functions_definitions:
            funcsInfo[f.name]={}
            ds_f=ast.get_docstring(f)
            docstring=docParse(ds_f)
            funcsInfo[f.name]["doc"]={}
            funcsInfo[f.name]["doc"]["long_description"]=docstring.long_description
            funcsInfo[f.name]["doc"]["short_description"]=docstring.short_description
            funcsInfo[f.name]["doc"]["args"]={}
            for i in docstring.params:
                funcsInfo[f.name]["doc"]["args"][i.arg_name]={}
                funcsInfo[f.name]["doc"]["args"][i.arg_name]["description"]=i.description
                funcsInfo[f.name]["doc"]["args"][i.arg_name]["type_name"]=i.type_name
                #funcsInfo[f.name]["doc"]["args"][i.arg_name]["is_optional"]=i.is_optional
                #funcsInfo[f.name]["doc"]["args"][i.arg_name]["default"]=i.default
            if docstring.returns:
                r=docstring.returns
                funcsInfo[f.name]["doc"]["returns"]={}
                funcsInfo[f.name]["doc"]["returns"]["description"]=r.description
                funcsInfo[f.name]["doc"]["returns"]["type_name"]=r.type_name
                #funcsInfo[f.name]["doc"]["returns"]["is_generator"]=r.is_generator
                #funcsInfo[f.name]["doc"]["returns"]["return_name"]=r.return_name
            funcsInfo[f.name]["doc"]["raises"]={}
            for num, i in enumerate(docstring.raises):
                funcsInfo[f.name]["doc"]["raises"][num]={}
                funcsInfo[f.name]["doc"]["raises"][num]["description"]=i.description
                funcsInfo[f.name]["doc"]["raises"][num]["type_name"]=i.type_name

            funcsInfo[f.name]["args"]=[a.arg for a in f.args.args]
            rs = [ node for node in ast.walk(f) if isinstance(node, (ast.Return, ))]
            funcsInfo[f.name]["returns"] = [self._get_ids(r.value) for r in rs]
            funcsInfo[f.name]["min_max_lineno"] = self._compute_interval(f)
        return funcsInfo



    def _get_ids(self,elt):
        """_get_ids extracts identifiers if present. 
         If not return None

        :param self self: represent the instance of the class
        :param ast.node elt: AST node
        :return list: list of identifiers
        """
        if isinstance(elt, (ast.List, )) or isinstance(elt, (ast.Tuple, )):
            # For tuple or list get id of each item if item is a Name
            return [x.id for x in elt.elts if isinstance(x, (ast.Name, ))]
        if isinstance(elt, (ast.Name, )):
            return [elt.id]

    def _compute_interval(self, node):
        """_compute_interval extract the lines (min and max)
         for a given class, function or method.

        :param self self: represent the instance of the class
        :param ast.node node: AST node
        :return set: min and max lines
        """
        min_lineno = node.lineno
        max_lineno = node.lineno
        for node in ast.walk(node):
            if hasattr(node, "lineno"):
                min_lineno = min(min_lineno, node.lineno)
                max_lineno = max(max_lineno, node.lineno)
        return (min_lineno, max_lineno + 1)

    def _formatFlow(self, s):
        """_formatFlow reformats the control flow output
        as a text.

        :param self self: represent the instance of the class
        :param cfg_graph s: control flow graph 
        :return str: cfg formated as a text
        """

        result = ""
        shifts = []     # positions of opening '<'
        pos = 0         # symbol position in a line
        nextIsList = False

        def IsNextList(index, maxIndex, buf):
            if index == maxIndex:
                return False
            if buf[index + 1] == '<':
                return True
            if index < maxIndex - 1:
                if buf[index + 1] == '\n' and buf[index + 2] == '<':
                    return True
            return False
  
        maxIndex = len(s) - 1
        for index in range(len(s)):
            sym = s[index]
            if sym == "\n":
                lastShift = shifts[-1]
                result += sym + lastShift * " "
                pos = lastShift
                if index < maxIndex:
                    if s[index + 1] not in "<>":
                        result += " "
                        pos += 1
                continue
            if sym == "<":
                if nextIsList == False:
                    shifts.append(pos)
                else:
                    nextIsList = False
                pos += 1
                result += sym
                continue
            if sym == ">":
                shift = shifts[-1]
                result += '\n'
                result += shift * " "
                pos = shift
                result += sym
                pos += 1
                if IsNextList(index, maxIndex, s):
                    nextIsList = True
                else:
                    del shifts[-1]
                    nextIsList = False
                continue
            result += sym
            pos += 1
        return result


def create_output_dirs(outputDir):
       """create_output_dirs creates two subdirectories
       to save the results. ControlFlow to save the
       cfg information (txt and PNG) and JsonFiles to
       save the aggregated json file with all the information
       extracted per file. 

       :param str outputDir: Output Directory in which the new subdirectories
                          will be created.
       """

       controlFlowDir=outputDir+"/ControlFlow"

       if not os.path.exists(controlFlowDir):
           print("Creating cf %s" % controlFlowDir)
           os.makedirs(controlFlowDir)
       else:
           pass
       jsonDir= outputDir+"/JsonFiles"

       if not os.path.exists(jsonDir):
           print("Creating jsDir:%s" %jsonDir)
           os.makedirs(jsonDir)
       else:
           pass
       return controlFlowDir, jsonDir
        


def main(args=None):

    if len(sys.argv) < 2:
        print('You need to specify the file to inspect')
        sys.exit()

    input_path = sys.argv[1]

    if (not os.path.isfile(input_path)) and (not os.path.isdir(input_path)):
        print('The file or directory specified does not exist')
        sys.exit()

    if os.path.isfile(input_path):
        cfDir, jsonDir=create_output_dirs(outputPath)
        code_info=Code_Inspection(input_path,cfDir, jsonDir)

    else:
       dirInfo={}
       for subdir, dirs, files in os.walk(input_path):
           dirs[:] = [d for d in dirs if not d.startswith('.')]
           dirs[:] = [d for d in dirs if not d.startswith('__')]
           files = [f for f in files if not f.startswith('.')]
           files = [f for f in files if not f.startswith('__')]
           for f in files:
               if ".py" in f: 
                   path=os.path.join(subdir, f)
                   outputDir=outputPath+"/"+os.path.basename(subdir)
                   cfDir, jsonDir=create_output_dirs(outputDir)
                   code_info=Code_Inspection(path,cfDir, jsonDir)
                   dirInfo[outputDir]=code_info.fileJson

       json_file=outputPath + "/DirectoryInfo.json" 
       with open(json_file, 'w') as outfile:
           json.dump(dirInfo, outfile)


if __name__ == "__main__":
    main()
